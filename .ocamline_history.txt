
Qed.

Lemma rev_aux_len : forall (A : Set), forall (acc val : list A), 
   plus (length A acc) (length A val) = length A (rev_aux A val acc).
undo.

Qed.

Lemma plus_zero : forall (n : nat), n = plus 0 n.

Proof.

intro.
 induction n.

+ compute.
 refl.

+ rewrite (eq_sym nat n (plus zero n) iH) 2.

  simpl.
undo.

Fixpoint length (A : Set) (val : list A) {struct val} :=
  match val in list return nat with
  | nil => 0
  | cns _ xs => succ (length A xs)
  end.

Fixpoint plus n m {struct m} :=
  match m return nat with
    | zero => n
    | succ k => succ (plus n k)
  end.

Lemma succ_plus : forall n m, succ (plus n m) = plus (succ n) m.

Proof.

intros.
 revert n.
 
induction m; intros; try obs.

simpl; rewrite (iH n); refl.

Qed.

Lemma plus_zero : forall (n : nat), n = plus 0 n.

Proof.

intro.
 induction n.

+ compute.
 refl.

+ rewrite (eq_sym nat n (plus zero n) iH) 2.

  simpl.
 refl.

Qed.

Lemma rev_aux_len : forall (A : Set), forall (acc val : list A), 
   plus (length A acc) (length A val) = length A (rev_aux A val acc).
undo.
 
induction m; intros; try obs.

simpl; rewrite (iH n); refl.

Qed.

Lemma plus_zero : forall (n : nat), n = plus 0 n.

Proof.

intro.
 induction n.

+ compute.
 refl.

+ rewrite (eq_sym nat n (plus zero n) iH) 2.

  compute.
 refl.

Qed.

Lemma rev_aux_len : forall (A : Set), forall (acc val : list A), 
   plus (length A acc) (length A val) = length A (rev_aux A val acc).

Proof.

intros.
undo.
